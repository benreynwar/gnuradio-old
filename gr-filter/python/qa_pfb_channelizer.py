#!/usr/bin/env python
#
# Copyright 2012 Free Software Foundation, Inc.
#
# This file is part of GNU Radio
#
# GNU Radio is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3, or (at your option)
# any later version.
#
# GNU Radio is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with GNU Radio; see the file COPYING.  If not, write to
# the Free Software Foundation, Inc., 51 Franklin Street,
# Boston, MA 02110-1301, USA.
#
import math

from gnuradio import gr, gr_unittest
import filter_swig as filter

# Import from local folder
from pfb_channelizer_hier_ccf import pfb_channelizer_hier_ccf

def convolve(X, Y):
    """
    Convolves two series.  Not used in test suite but useful during debugging.
    """
    N = len(X)
    ss= []
    for n in range(0, len(Y)):
        s = 0
        for l in range(0, len(X)):
            s += X[l].conjugate()*Y[(n+l)%len(Y)]
        ss.append(s)
    return ss

def pychannelizer(self, flt, data, M):
    """
    Implements a pfb channelizer in python.

    Not used in test suite but it is nice to have if one ever needs
    to debug.
    """
    # Put numpy import inside function since we don't typically use this.
    from numpy import fft
    flt = list(flt)
    if len(data)%M != 0:
        data = data[:int(len(data)/M)*M]
    if len(flt)%M != 0:
        flt = flt + [0] * (M - len(flt)%M)
    flts = [flt[i::M] for i in range(M)]
    css = [data[i::M] for i in range(M)]
    convolved = [convolve(flts[i], css[i]) for i in range(M)]
    channels = []
    for k in range(M):
        filtered = [fft.fft(c)[k] for c in zip(*convolved)]
        channels.append([x for x in filtered])
    return channels

class pfb_channelizer_wrapper(gr.hier_block2):
    """
    Wraps pfb_channelizer_ccf in wrapper so it can take a single stream rather
    than n_chans of them.
    """

    def __init__(self, M, taps, oversample_rate):
	gr.hier_block2.__init__(self, "pfb_channelizer_hier_ccf",
				gr.io_signature(1, 1, gr.sizeof_gr_complex),
				gr.io_signature(M, M, gr.sizeof_gr_complex))
        s2ss = gr.stream_to_streams(gr.sizeof_gr_complex, M)
        pfb = filter.pfb_channelizer_ccf(M, taps, oversample_rate)
        self.connect(self, s2ss)
        for i in range(0, M):
            self.connect((s2ss, i), (pfb, i))
            self.connect((pfb, i), (self, i))


class test_pfb_channelizer(gr_unittest.TestCase):
    """
    Test the pfb_channelizer_ccf block as well as the python
    hierarchical pfb_channelizer_hier_ccf block.
    """

    def setUp(self):
        self.tb = gr.top_block()
        self.N = 1000         # number of samples to use
        self.M = 5            # Number of channels to channelize
        self.fs = 1000        # baseband sampling rate
        self.ifs = self.M*self.fs       # input samp rate to channelizer
        self.Ntest = 50
        self.freqs = [-200, -100, 0, 100, 200]
        self.taps = filter.firdes.low_pass_2(
            1, self.ifs, 500, 50, attenuation_dB=80,
            window=filter.firdes.WIN_BLACKMAN_hARRIS)

    def tearDown(self):
        self.tb = None

    def test_000(self):
        """Test pfb_channelizer_ccf."""
        def make_block(M, taps):
            pfb = pfb_channelizer_wrapper(M, taps, 1)
            return pfb
        self.channelizer_test(make_block)

    def test_001(self):
        """Test pfb_channelizer_hier_ccf."""
        def make_block(M, taps):
            pfb = pfb_channelizer_hier_ccf(M, taps=taps)
            return pfb
        self.channelizer_test(make_block)

    def get_expected_data(self, L):
        """
        Create known data as complex sinusoids at the different
        baseband freqs the different channel numbering (sfreqs vs
        freqs) is due to channelizer output order.
        """
        fs = 1000
        def make_data(f):
            t = [float(x)/fs for x in  xrange(L)]
            return [math.cos(2*math.pi*f*x) + 1j*math.sin(2*math.pi*f*x)
                    for x in t]
        sfreqs = [self.freqs[2], self.freqs[3], self.freqs[4], self.freqs[0],
                  self.freqs[1]]        
        expected_data = [make_data(f) for f in sfreqs]
        return expected_data

    def get_input_data(self):
        """
        Get the raw data generated by addition of sinusoids.
        Useful for debugging.
        """
        tb = gr.top_block()
        signals = []
        add = gr.add_cc()
        for i in xrange(len(self.freqs)):
            f = self.freqs[i] + (self.M/2-self.M+i+1)*self.fs
            signals.append(gr.sig_source_c(self.ifs, gr.GR_SIN_WAVE, f, 1))
            tb.connect(signals[i], (add,i))
        head = gr.head(gr.sizeof_gr_complex, self.N)
        snk = gr.vector_sink_c()
        tb.connect(add, head, snk)
        tb.run()
        input_data = snk.data()
        return input_data

    def _test_pychannelizer(self):
        """
        Test the python channelizer.
        """
        freqs = [-200, -100, 0, 100, 200]
        input_data = self.get_input_data()
        channels = self.pychannelizer(self.taps, input_data, self.M) 
        expected_data = self.get_expected_data(len(channels[0]))
        for i, ed, dd in zip(range(self.M), expected_data, channels):
            # Correct for phase.
            pf = ed[-1]/dd[-1]
            dd = [d*pf for d in dd]
            self.assertComplexTuplesAlmostEqual(ed[-self.Ntest:], dd[-self.Ntest:], 3)

    def channelizer_test(self, block_factory):
        """
        Test a channelizer.

        Args:
           block_factory: A function that returns the channelizer block.
        """
        signals = list()
        add = gr.add_cc()
        freqs = [-200, -100, 0, 100, 200]
        for i in xrange(len(freqs)):
            f = freqs[i] + (self.M/2-self.M+i+1)*self.fs
            signals.append(gr.sig_source_c(self.ifs, gr.GR_SIN_WAVE, f, 1))
            self.tb.connect(signals[i], (add,i))
        head = gr.head(gr.sizeof_gr_complex, self.N)
        pfb = block_factory(self.M, self.taps)
        self.tb.connect(add, head, pfb)
        snks = list()
        for i in xrange(self.M):
            snks.append(gr.vector_sink_c())
            self.tb.connect((pfb, i), snks[i])
        self.tb.run() 

        # Get the delay of the output.
        L = len(snks[0].data())
        delay = 1.0 * len(self.taps)/self.M
        if int(delay) == delay:
            delay = int(delay)
        else:
            delay = int(delay)+1
        expected_data = self.get_expected_data(L+delay)
        expected_data = [e[delay:] for e in expected_data]
        dst_data = [snk.data() for snk in snks]
        ed = expected_data[0]
        dd = dst_data[0]
        for ed, dd in zip(expected_data, dst_data):
            # Correct for phase
            pf = ed[-1]/dd[-1]
            dd = [d*pf for d in dd]
            self.assertComplexTuplesAlmostEqual(ed[-self.Ntest:], dd[-self.Ntest:], 3)

if __name__ == '__main__':
    gr_unittest.run(test_pfb_channelizer, "test_pfb_channelizer.xml")
